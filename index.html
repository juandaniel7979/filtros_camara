<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cámara con Efecto de Esferas, Filtros, Audio y Fotos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        .main-content {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap; /* Permite que los paneles se envuelvan en pantallas pequeñas */
        }
        .camera-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        video, canvas {
            border: 2px solid #ccc;
            background-color: #eee;
            max-width: 640px;
            height: auto;
        }
        #audioVisualizerCanvas {
            margin-top: 20px;
            border: 2px solid #ccc;
            background-color: #333;
        }
        .controls {
            padding: 15px;
            border: 1px solid #ddd;
            background-color: #fff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 250px;
            flex-grow: 1;
        }
        .controls.camera-controls, .controls.audio-controls {
            flex-basis: 300px;
        }
        .controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .controls input[type="range"] {
            width: 150px;
        }
        /* Estilo específico para el checkbox de habilitar/deshabilitar esferas */
        .controls .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: flex-start; /* Alinea texto y checkbox a la izquierda */
        }
        .controls .checkbox-label input[type="checkbox"] {
            width: auto; /* Permite que el checkbox tenga su tamaño natural */
            margin-left: 0;
        }
        
        select, button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        button:hover {
            background-color: #e9e9e9;
        }
        .record-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .record-buttons button {
            flex: 1;
        }
        .record-buttons button.recording {
            background-color: #ff6666;
            color: white;
        }
        #recordedAudio {
            margin-top: 20px;
            display: none;
        }
        /* Estilos de la galería */
        .gallery-section {
            margin-top: 30px;
            width: 640px; /* Ancho similar al canvas */
            text-align: center;
            border-top: 2px solid #ddd;
            padding-top: 20px;
        }
        .gallery-actions { /* Contenedor para botones de acción de la galería */
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        #imageGallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            border: 1px solid #eee;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
        }
        .gallery-item {
            width: 150px; /* Tamaño de las miniaturas */
            height: 112px; /* Proporción 4:3 para 150px de ancho */
            border: 1px solid #ccc;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #f0f0f0;
        }
        .gallery-item img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        .gallery-item .delete-btn, .gallery-item .download-btn-individual { /* Estilo para ambos botones superpuestos */
            position: absolute;
            top: 5px;
            width: 25px;
            height: 25px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10; /* Asegura que estén por encima de la imagen */
        }
        .gallery-item .delete-btn {
            right: 5px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
        }
        .gallery-item .download-btn-individual {
            left: 5px;
            background-color: rgba(0, 128, 0, 0.7); /* Verde */
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 16px; /* Icono de descarga */
            line-height: 1; /* Ajusta para centrar el icono */
            padding-bottom: 2px; /* Pequeño ajuste para centrado visual */
        }

        .gallery-item:hover .delete-btn,
        .gallery-item:hover .download-btn-individual {
            opacity: 1;
        }

    </style>
</head>
<body>
    <h1>Cámara con Efecto de Esferas, Filtros, Audio y Fotos</h1>

    <div class="main-content">
        <div class="controls camera-controls">
            <h2>Controles de Video</h2>
            <label for="filterSelect">
                Seleccionar Filtro:
                <select id="filterSelect">
                    <option value="none">Ninguno</option>
                    <option value="sepia">Sepia</option>
                    <option value="negative">Negativo</option>
                    <option value="grayscale">Escala de Grises</option>
                    <option value="warmTone">Tono Cálido</option>
                    <option value="coldDarkBlues">Oscuros a Azules Fríos</option>
                    <option value="purpleCyanGradient">Degradado Morado/Cyan (Oscuros)</option>
                    <option value="saturateReds">Saturar Rojos</option>
                    <option value="nightVision">Visión Nocturna</option>
                    <option value="heatmap">Mapa de Calor</option>
                </select>
            </label>

            <label class="checkbox-label"> <input type="checkbox" id="enableSpheresCheckbox" checked>
                Habilitar Efecto de Esferas
            </label>

            <label for="pixelationRange">
                Tamaño de Píxel/Esfera:
                <input type="range" id="pixelationRange" min="5" max="50" value="15">
                <span id="pixelationValue">15</span>
            </label>
            <label for="blurAmount">
                Intensidad de Difuminado:
                <input type="range" id="blurAmount" min="0" max="20" value="5">
                <span id="blurValue">5</span>
            </label>
            <label for="randomnessAmount">
                Aleatoriedad de Posición:
                <input type="range" id="randomnessAmount" min="0" max="100" value="50">
                <span id="randomnessValue">50</span>
            </label>
            <button id="takePictureButton">Tomar Foto</button>
        </div>

        <div class="camera-section">
            <video id="video" width="640" height="480" autoplay muted style="display: none;"></video>
            <canvas id="outputCanvas" width="640" height="480"></canvas>
            <canvas id="tempCanvas" width="640" height="480" style="display: none;"></canvas>
        </div>

        <div class="controls audio-controls">
            <h2>Controles de Audio</h2>
            <button id="startAudioButton">Iniciar Audio</button>

            <label for="voiceFilterSelect">
                Filtro de Voz:
                <select id="voiceFilterSelect">
                    <option value="none">Normal</option>
                    <option value="darthVader">Darth Vader (Grave)</option>
                    <option value="robot">Robot</option>
                    <option value="alien">Alien (Aguda)</option>
                    <option value="megaphone">Megáfono</option>
                    <option value="distortion">Distorsión Ligera</option>
                </select>
            </label>

            <label for="delayTime">
                Tiempo de Delay (segundos):
                <input type="range" id="delayTime" min="0" max="2" step="0.05" value="0.2">
                <span id="delayTimeValue">0.20</span>
            </label>
            <label for="delayFeedback">
                Retroalimentación Delay (%):
                <input type="range" id="delayFeedback" min="0" max="90" value="50">
                <span id="delayFeedbackValue">50</span>
            </label>
            <label for="delayVolume">
                Volumen del Delay:
                <input type="range" id="delayVolume" min="0" max="1" step="0.01" value="0.7">
                <span id="delayVolumeValue">0.70</span>
            </label>
            
            <h3>Grabación</h3>
            <div class="record-buttons">
                <button id="recordButton">Grabar</button>
                <button id="stopRecordButton" disabled>Detener Grabación</button>
            </div>
            <audio id="recordedAudio" controls></audio>
        </div>
    </div>
    
    <canvas id="audioVisualizerCanvas" width="640" height="100"></canvas>

    <div class="gallery-section">
        <h2>Galería de Fotos</h2>
        <div class="gallery-actions">
            <button id="downloadAllPicturesButton" style="display: none;">Descargar Todas las Fotos (.zip)</button>
        </div>
        <div id="imageGallery">
            <p id="noPhotosMessage">No hay fotos aún. ¡Toma una!</p>
        </div>
    </div>

    <script>
        // --- Variables DOM para Video y Filtros ---
        const video = document.getElementById('video');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d', { willReadFrequently: true });
        const tempCanvas = document.getElementById('tempCanvas');
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

        const pixelationRange = document.getElementById('pixelationRange');
        const pixelationValueSpan = document.getElementById('pixelationValue');
        const blurAmountRange = document.getElementById('blurAmount');
        const blurValueSpan = document.getElementById('blurValue');
        const randomnessAmountRange = document.getElementById('randomnessAmount');
        const randomnessValueSpan = document.getElementById('randomnessValue'); 
        const filterSelect = document.getElementById('filterSelect');
        const takePictureButton = document.getElementById('takePictureButton'); 
        const enableSpheresCheckbox = document.getElementById('enableSpheresCheckbox'); // Nuevo checkbox

        let pixelSize = parseInt(pixelationRange.value);
        let blurRadius = parseInt(blurAmountRange.value);
        let randomnessFactor = parseInt(randomnessAmountRange.value) / 100;
        let currentImageFilter = filterSelect.value; 
        let spheresEnabled = enableSpheresCheckbox.checked; // Estado inicial del checkbox

        // --- Variables DOM para Audio ---
        const startAudioButton = document.getElementById('startAudioButton');
        const delayTimeRange = document.getElementById('delayTime');
        const delayTimeValueSpan = document.getElementById('delayTimeValue');
        const delayFeedbackRange = document.getElementById('delayFeedback');
        const delayFeedbackValueSpan = document.getElementById('delayFeedbackValue');
        const delayVolumeRange = document.getElementById('delayVolume');
        const delayVolumeValueSpan = document.getElementById('delayVolumeValue');
        const voiceFilterSelect = document.getElementById('voiceFilterSelect'); 
        const recordButton = document.getElementById('recordButton');
        const stopRecordButton = document.getElementById('stopRecordButton');
        const recordedAudio = document.getElementById('recordedAudio');
        const audioVisualizerCanvas = document.getElementById('audioVisualizerCanvas'); 
        const visualizerCtx = audioVisualizerCanvas.getContext('2d'); 

        let currentVoiceFilter = voiceFilterSelect.value; 

        // --- Variables DOM para Galería ---
        const imageGallery = document.getElementById('imageGallery'); 
        const noPhotosMessage = document.getElementById('noPhotosMessage'); 
        const downloadAllPicturesButton = document.getElementById('downloadAllPicturesButton'); 
        let capturedImages = []; 

        // --- Contexto de Audio y Nodos ---
        let audioContext;
        let mediaStreamSource;
        let delayNode;
        let feedbackGainNode; 
        let delayOutputGainNode; 
        let mainGainNode; 
        let voiceFilterNode = null; 
        let voiceFilterGainNode = null; 
        let analyserNode; 

        let mediaRecorder;
        const audioChunks = [];
        let isRecording = false;

        // --- Event Listeners para Controles de Video y Filtros ---
        pixelationRange.oninput = (e) => {
            pixelSize = parseInt(e.target.value);
            pixelationValueSpan.textContent = pixelSize;
        };

        blurAmountRange.oninput = (e) => {
            blurRadius = parseInt(e.target.value);
            blurValueSpan.textContent = blurRadius;
        };

        randomnessAmountRange.oninput = (e) => {
            randomnessFactor = parseInt(e.target.value) / 100;
            randomnessValueSpan.textContent = parseInt(e.target.value);
        };

        filterSelect.onchange = (e) => {
            currentImageFilter = e.target.value;
        };

        enableSpheresCheckbox.onchange = (e) => { // Nuevo event listener para el checkbox
            spheresEnabled = e.target.checked;
        };

        // --- Acceso a la Cámara (Video) ---
        navigator.mediaDevices.getUserMedia({ video: true })
            .then((stream) => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    requestAnimationFrame(processVideoFrame);
                };
            })
            .catch((err) => {
                console.error("Error al acceder a la cámara: ", err);
                alert("No se pudo acceder a la cámara. Asegúrate de haber dado permiso.");
            });

        // --- Funciones de Filtro de Imagen ---
        const imageFilters = { 
            none: (pixels, numPixels) => {},
            sepia: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const r = pixels[i]; const g = pixels[i + 1]; const b = pixels[i + 2];
                    pixels[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    pixels[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    pixels[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                }
            },
            negative: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    pixels[i] = 255 - pixels[i];
                    pixels[i + 1] = 255 - pixels[i + 1];
                    pixels[i + 2] = 255 - pixels[i + 2];
                }
            },
            grayscale: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    pixels[i] = avg; pixels[i + 1] = avg; pixels[i + 2] = avg;
                }
            },
            warmTone: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    pixels[i] = Math.min(255, pixels[i] + 40);
                    pixels[i + 1] = Math.min(255, pixels[i + 1] + 20);
                    pixels[i + 2] = Math.max(0, pixels[i + 2] - 20);
                }
            },
            coldDarkBlues: (pixels, numPixels) => {
                const threshold = 70; const blueBoost = 100; const minBrightness = 20;
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const r = pixels[i]; const g = pixels[i + 1]; const b = pixels[i + 2];
                    const brightness = (r + g + b) / 3;
                    if (brightness < threshold && brightness > minBrightness) {
                        pixels[i] = Math.max(0, r - 50);
                        pixels[i + 1] = Math.max(0, g - 30);
                        pixels[i + 2] = Math.min(255, b + blueBoost);
                    } else if (brightness <= minBrightness) {
                        pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = Math.min(255, b + 50);
                    }
                }
            },
            purpleCyanGradient: (pixels, numPixels) => {
                const darkThreshold = 80;
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const r = pixels[i]; const g = pixels[i + 1]; const b = pixels[i + 2];
                    const avg = (r + g + b) / 3;
                    if (avg < darkThreshold) {
                        const ratio = 1 - (avg / darkThreshold);
                        const newR = Math.max(0, Math.min(255, Math.floor(128 * ratio)));
                        const newG = Math.max(0, Math.min(255, Math.floor(128 * (1 - ratio))));
                        const newB = Math.max(0, Math.min(255, Math.floor(128)));
                        pixels[i] = newR; pixels[i + 1] = newG; pixels[i + 2] = newB;
                    }
                }
            },
            saturateReds: (pixels, numPixels) => {
                const saturationFactor = 1.5; const redThreshold = 100;
                for (let i = 0; i < numPixels * 4; i += 4) {
                    let r = pixels[i]; let g = pixels[i + 1]; let b = pixels[i + 2];
                    if (r > g && r > b && r > redThreshold) {
                        r = Math.min(255, r * saturationFactor);
                        g = Math.max(0, g - 20);
                        b = Math.max(0, b - 20);
                    }
                    pixels[i] = r; pixels[i + 1] = g; pixels[i + 2] = b;
                }
            },
            nightVision: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];

                    const avg = (r + g + b) / 3;

                    let green = Math.min(255, avg * 1.5);
                    let red = Math.min(255, avg * 0.5);
                    let blue = Math.min(255, avg * 0.5);

                    if (avg < 100) {
                        green = Math.min(255, green + 50);
                        red = Math.max(0, red - 30);
                        blue = Math.max(0, blue - 30);
                    }

                    pixels[i] = red;
                    pixels[i + 1] = green;
                    pixels[i + 2] = blue;
                }
            },
            heatmap: (pixels, numPixels) => {
                for (let i = 0; i < numPixels * 4; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];

                    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255; 

                    let newR, newG, newB;

                    if (brightness < 0.25) { 
                        newR = 0;
                        newG = Math.floor(255 * brightness * 4); 
                        newB = 255;
                    } else if (brightness < 0.5) { 
                        newR = 0;
                        newG = 255;
                        newB = Math.floor(255 * (1 - (brightness - 0.25) * 4)); 
                    } else if (brightness < 0.75) { 
                        newR = Math.floor(255 * (brightness - 0.5) * 4); 
                        newG = 255;
                        newB = 0;
                    } else { 
                        newR = 255;
                        newG = Math.floor(255 * (1 - (brightness - 0.75) * 4)); 
                        newB = 0;
                    }

                    pixels[i] = newR;
                    pixels[i + 1] = newG;
                    pixels[i + 2] = newB;
                }
            }
        };

        // --- Bucle de Procesamiento de Video (MODIFICADO) ---
        function processVideoFrame() {
            if (video.paused || video.ended) {
                return;
            }

            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;

            outputCanvas.width = videoWidth;
            outputCanvas.height = videoHeight;
            tempCanvas.width = videoWidth;
            tempCanvas.height = videoHeight;

            tempCtx.drawImage(video, 0, 0, videoWidth, videoHeight); // Dibuja el frame original en el tempCanvas
            const imageData = tempCtx.getImageData(0, 0, videoWidth, videoHeight);
            const pixels = imageData.data;

            // Aplica el filtro de imagen SIEMPRE, incluso si las esferas están deshabilitadas
            if (imageFilters[currentImageFilter]) { 
                imageFilters[currentImageFilter](pixels, videoWidth * videoHeight);
            }

            ctx.clearRect(0, 0, videoWidth, videoHeight); // Limpia el canvas de salida

            if (spheresEnabled) { // <--- NUEVA CONDICIÓN AQUÍ
                // Lógica para dibujar esferas difuminadas (si está habilitado)
                for (let y = 0; y < videoHeight; y += pixelSize) {
                    for (let x = 0; x < videoWidth; x += pixelSize) {
                        let r = 0, g = 0, b = 0, count = 0;
                        for (let dy = 0; dy < pixelSize && (y + dy) < videoHeight; dy++) {
                            for (let dx = 0; dx < pixelSize && (x + dx) < videoWidth; dx++) {
                                const index = ((y + dy) * videoWidth + (x + dx)) * 4;
                                r += pixels[index]; g += pixels[index + 1]; b += pixels[index + 2];
                                count++;
                            }
                        }

                        if (count > 0) {
                            r = Math.floor(r / count); g = Math.floor(g / count); b = Math.floor(b / count);
                            const baseCenterX = x + pixelSize / 2;
                            const baseCenterY = y + pixelSize / 2;
                            const offsetX = (Math.random() - 0.5) * pixelSize * randomnessFactor;
                            const offsetY = (Math.random() - 0.5) * pixelSize * randomnessFactor;
                            const finalCenterX = baseCenterX + offsetX;
                            const finalCenterY = baseCenterY + offsetY;
                            const radius = pixelSize / 2 * 0.8;

                            ctx.beginPath();
                            ctx.arc(finalCenterX, finalCenterY, radius, 0, Math.PI * 2);
                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.7)`;
                            ctx.shadowBlur = blurRadius;
                            ctx.fill();
                            ctx.closePath();
                            ctx.shadowColor = 'rgba(0,0,0,0)';
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            } else {
                // Si las esferas están deshabilitadas, dibuja la imagen filtrada directamente en el canvas de salida
                // Primero, aplica los datos de píxeles modificados al tempCtx (si el filtro modificó imageData)
                tempCtx.putImageData(imageData, 0, 0); 
                // Luego, dibuja la imagen del tempCanvas al outputCanvas
                ctx.drawImage(tempCanvas, 0, 0, videoWidth, videoHeight);
            }
            requestAnimationFrame(processVideoFrame);
        }

        // --- Funciones y Nodos de Audio ---

        function setupVoiceFilterNodes() {
            if (!audioContext || !mediaStreamSource) {
                return;
            }

            try { mediaStreamSource.disconnect(); } catch (e) { /* console.warn("mediaStreamSource disconnect error:", e.message); */ }
            if (voiceFilterNode) { try { voiceFilterNode.disconnect(); } catch (e) { /* console.warn("voiceFilterNode disconnect error:", e.message); */ } }
            if (voiceFilterGainNode) { try { voiceFilterGainNode.disconnect(); } catch (e) { /* console.warn("voiceFilterGainNode disconnect error:", e.message); */ } }
            
            voiceFilterNode = null; 
            voiceFilterGainNode = null; 

            switch (currentVoiceFilter) {
                case 'none':
                    mediaStreamSource.connect(mainGainNode);
                    break;
                case 'darthVader': 
                    voiceFilterNode = audioContext.createBiquadFilter();
                    voiceFilterNode.type = 'lowpass'; 
                    voiceFilterNode.frequency.value = 150; 
                    voiceFilterNode.Q.value = 0.8; 
                    voiceFilterGainNode = audioContext.createGain();
                    voiceFilterGainNode.gain.value = 1.8; 
                    mediaStreamSource.connect(voiceFilterNode);
                    voiceFilterNode.connect(voiceFilterGainNode);
                    voiceFilterGainNode.connect(mainGainNode);
                    break;
                case 'robot': 
                    voiceFilterNode = audioContext.createBiquadFilter();
                    voiceFilterNode.type = 'lowpass';
                    voiceFilterNode.frequency.value = 600; 
                    voiceFilterNode.Q.value = 15; 
                    voiceFilterGainNode = audioContext.createGain();
                    voiceFilterGainNode.gain.value = 1.0;
                    mediaStreamSource.connect(voiceFilterNode);
                    voiceFilterNode.connect(voiceFilterGainNode);
                    voiceFilterGainNode.connect(mainGainNode);
                    break;
                case 'alien': 
                    voiceFilterNode = audioContext.createBiquadFilter();
                    voiceFilterNode.type = 'highpass'; 
                    voiceFilterNode.frequency.value = 2000; 
                    voiceFilterNode.Q.value = 1;
                    voiceFilterGainNode = audioContext.createGain();
                    voiceFilterGainNode.gain.value = 1.2;
                    mediaStreamSource.connect(voiceFilterNode);
                    voiceFilterNode.connect(voiceFilterGainNode);
                    voiceFilterGainNode.connect(mainGainNode);
                    break;
                case 'megaphone': 
                    voiceFilterNode = audioContext.createBiquadFilter();
                    voiceFilterNode.type = 'bandpass'; 
                    voiceFilterNode.frequency.value = 900; 
                    voiceFilterNode.Q.value = 8; 
                    voiceFilterGainNode = audioContext.createGain();
                    voiceFilterGainNode.gain.value = 2.5; 
                    mediaStreamSource.connect(voiceFilterNode);
                    voiceFilterNode.connect(voiceFilterGainNode);
                    voiceFilterGainNode.connect(mainGainNode);
                    break;
                case 'distortion': 
                    voiceFilterNode = audioContext.createWaveShaper();
                    voiceFilterNode.curve = makeDistortionCurve(80); 
                    voiceFilterGainNode = audioContext.createGain();
                    voiceFilterGainNode.gain.value = 1.5; 
                    mediaStreamSource.connect(voiceFilterNode);
                    voiceFilterNode.connect(voiceFilterGainNode);
                    voiceFilterGainNode.connect(mainGainNode);
                    break;
            }
        }

        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50;
            let n_samples = 44100;
            let curve = new Float32Array(n_samples);
            let deg = Math.PI / 180;
            let i = 0;
            let x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        };


        // Función para iniciar el contexto de audio y obtener el stream del micrófono
        async function startAudioProcessing() {
            if (audioContext && audioContext.state === 'running') {
                console.log('Audio ya está corriendo.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mediaStreamSource = audioContext.createMediaStreamSource(stream);

                mainGainNode = audioContext.createGain(); 
                delayNode = audioContext.createDelay(2.0); 
                delayNode.delayTime.value = parseFloat(delayTimeRange.value); 

                feedbackGainNode = audioContext.createGain();
                feedbackGainNode.gain.value = parseFloat(delayFeedbackRange.value) / 100 * 0.9; 

                delayOutputGainNode = audioContext.createGain();
                delayOutputGainNode.gain.value = parseFloat(delayVolumeRange.value);

                analyserNode = audioContext.createAnalyser(); 
                analyserNode.fftSize = 256; 

                delayNode.connect(feedbackGainNode);
                feedbackGainNode.connect(delayNode);

                mainGainNode.connect(audioContext.destination); 
                mainGainNode.connect(delayNode); 

                delayOutputGainNode.connect(audioContext.destination); 

                mainGainNode.connect(analyserNode); 
                delayOutputGainNode.connect(analyserNode);
                analyserNode.connect(audioContext.destination); 

                setupVoiceFilterNodes(); 
                
                console.log('Audio procesado y conectado.');
                startAudioButton.disabled = true;

                recordButton.disabled = false;
                stopRecordButton.disabled = true;

                drawVisualizer(); 

            } catch (err) {
                console.error("Error al acceder al micrófono o procesar audio: ", err);
                alert("No se pudo iniciar el procesamiento de audio. Asegúrate de haber dado permiso al micrófono. Detalle: " + err.name + " - " + err.message);
            }
        }

        // --- Bucle de Dibujo del Visualizador de Audio ---
        function drawVisualizer() {
            if (!analyserNode) return; 

            requestAnimationFrame(drawVisualizer); 

            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyserNode.getByteFrequencyData(dataArray); 

            visualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
            visualizerCtx.fillStyle = 'rgb(0, 0, 0)'; 
            visualizerCtx.fillRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);

            const barWidth = (audioVisualizerCanvas.width / bufferLength) * 2.5; 
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] / 2; 

                visualizerCtx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)'; 
                visualizerCtx.fillRect(x, audioVisualizerCanvas.height - barHeight, barWidth, barHeight);

                x += barWidth + 1; 
            }
        }


        // --- Event Listeners para Controles de Audio ---
        startAudioButton.onclick = startAudioProcessing;

        voiceFilterSelect.onchange = (e) => {
            currentVoiceFilter = e.target.value;
            if (audioContext && audioContext.state === 'running') {
                setupVoiceFilterNodes(); 
            }
        };

        delayTimeRange.oninput = (e) => {
            if (delayNode) {
                delayNode.delayTime.value = parseFloat(e.target.value);
            }
            delayTimeValueSpan.textContent = parseFloat(e.target.value).toFixed(2);
        };

        delayFeedbackRange.oninput = (e) => {
            if (feedbackGainNode) {
                feedbackGainNode.gain.value = parseFloat(e.target.value) / 100 * 0.9; 
            }
            delayFeedbackValueSpan.textContent = parseInt(e.target.value);
        };

        delayVolumeRange.oninput = (e) => {
            if (delayOutputGainNode) {
                delayOutputGainNode.gain.value = parseFloat(e.target.value);
            }
            delayVolumeValueSpan.textContent = parseFloat(e.target.value).toFixed(2);
        };


        // --- Grabación de Audio ---
        recordButton.onclick = async () => {
            if (!audioContext || audioContext.state !== 'running') {
                alert('Por favor, inicia el audio primero.');
                return;
            }

            const destination = audioContext.createMediaStreamDestination();
            
            mainGainNode.connect(destination); 
            delayOutputGainNode.connect(destination); 

            mediaRecorder = new MediaRecorder(destination.stream);
            audioChunks.length = 0;
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);
                recordedAudio.src = audioUrl;
                recordedAudio.style.display = 'block';
                console.log('Grabación finalizada. URL:', audioUrl);
                recordButton.textContent = 'Grabar';
                recordButton.disabled = false;
                stopRecordButton.disabled = true;
                isRecording = false;

                try { mainGainNode.disconnect(destination); } catch (e) { /* console.warn(e.message); */ }
                try { delayOutputGainNode.disconnect(destination); } catch (e) { /* console.warn(e.message); */ }
            };

            mediaRecorder.start();
            recordButton.textContent = 'Grabando...';
            recordButton.disabled = true;
            stopRecordButton.disabled = false;
            isRecording = true;
            console.log('Grabación iniciada.');
        };

        stopRecordButton.onclick = () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        };

        function setupAudioContextStateListener() {
            if (audioContext) {
                audioContext.onstatechange = () => {
                    console.log('AudioContext state:', audioContext.state);
                };
            }
        }

        // --- Funcionalidad de Tomar Foto y Galería ---
        takePictureButton.onclick = () => {
            // Capturar el contenido del outputCanvas
            const imageDataURL = outputCanvas.toDataURL('image/png'); // Exportar como PNG

            capturedImages.push(imageDataURL);

            renderGallery();
        };

        function renderGallery() {
            imageGallery.innerHTML = ''; 

            if (capturedImages.length === 0) {
                imageGallery.appendChild(noPhotosMessage); 
                downloadAllPicturesButton.style.display = 'none'; 
            } else {
                noPhotosMessage.remove(); 
                downloadAllPicturesButton.style.display = 'inline-block'; 

                capturedImages.forEach((dataURL, index) => {
                    const galleryItem = document.createElement('div');
                    galleryItem.classList.add('gallery-item');

                    const img = document.createElement('img');
                    img.src = dataURL;
                    img.alt = `Foto ${index + 1}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('delete-btn');
                    deleteButton.textContent = 'X';
                    deleteButton.title = 'Eliminar foto';
                    deleteButton.onclick = () => {
                        deleteImage(index);
                    };

                    const downloadButtonIndividual = document.createElement('button');
                    downloadButtonIndividual.classList.add('download-btn-individual');
                    downloadButtonIndividual.textContent = '⬇'; 
                    downloadButtonIndividual.title = 'Descargar esta foto';
                    downloadButtonIndividual.onclick = () => {
                        downloadImageIndividual(dataURL, index);
                    };

                    galleryItem.appendChild(img);
                    galleryItem.appendChild(deleteButton);
                    galleryItem.appendChild(downloadButtonIndividual);
                    imageGallery.appendChild(galleryItem);
                });
            }
        }

        function deleteImage(indexToDelete) {
            capturedImages.splice(indexToDelete, 1);
            renderGallery();
        }

        // --- Funciones de Descarga ---

        function downloadImageIndividual(dataURL, index) {
            const a = document.createElement('a');
            a.href = dataURL;
            const timestamp = new Date().toISOString().replace(/[:.-]/g, '');
            a.download = `foto_efecto_${timestamp}_${index + 1}.png`;
            document.body.appendChild(a); 
            a.click();
            document.body.removeChild(a); 
        }

        downloadAllPicturesButton.onclick = async () => {
            if (capturedImages.length === 0) {
                alert('No hay fotos en la galería para descargar.');
                return;
            }

            downloadAllPicturesButton.textContent = 'Generando ZIP...';
            downloadAllPicturesButton.disabled = true;

            const zip = new JSZip();

            for (let i = 0; i < capturedImages.length; i++) {
                const dataURL = capturedImages[i];
                const base64Data = dataURL.replace(/^data:image\/(png|jpeg|webp);base64,/, '');
                const timestamp = new Date().toISOString().replace(/[:.-]/g, '');
                const filename = `foto_efecto_${timestamp}_${i + 1}.png`;
                
                zip.file(filename, base64Data, { base64: true });
            }

            try {
                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, "mis_fotos_efecto.zip");
                alert('¡Fotos descargadas en un archivo ZIP!');
            } catch (err) {
                console.error("Error al generar o descargar el ZIP:", err);
                alert('Ocurrió un error al descargar el ZIP. Revisa la consola.');
            } finally {
                downloadAllPicturesButton.textContent = 'Descargar Todas las Fotos (.zip)';
                downloadAllPicturesButton.disabled = false;
            }
        };

        renderGallery();

    </script>
</body>
</html>